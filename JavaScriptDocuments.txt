Generators (or generator functions) :- ES6 introduced a new way of working with functions and iterators in the form of Generators.

	A generator is a function that can stop midway and then continue from where it stopped.
	A generator is a function that produces a sequence of results instead of a single value, i.e you generate ​a series of values.
	When called, generator functions do not initially execute their code. Instead, they return a special type of iterator, called a Generator. When a value is consumed by calling the generator's next method, the Generator function executes until it encounters the yield keyword.

“use strict”
The directive looks like a string: "use strict" or 'use strict'. When it is located at the top of a script, the whole script works the “modern” way.

Objects :- In JavaScript, an object is a standalone entity, with properties and type. Compare it with a car, for example. A car is an object, with properties. A car has a color, a design, weight, a material it is made of.

	var person = {
		firstName: "John",
		lastName : "Doe",
		id       : 5566,
		fullName : function() {
			return this.firstName + " " + this.lastName;
		}
	};
	name = person.fullName();
	name = person.fullName;
	console.log(name);
	------------------------------------------------
	
	class Animal {
	  constructor(name) {
		this.name = name;
	  }

	  speak() {
		console.log(`${this.name} makes a noise.`);
	  }
	}

	class Dog extends Animal {
	  constructor(name) {
		super(name); // call the super class constructor and pass in the name parameter
	  }

	  speak() {
		console.log(`${this.name} barks.`);
	  }
	}

	let d = new Dog('Mitzie');
	d.speak(); // Mitzie barks.
	
	--------------------------------------------------
		
Callback :- A callback is a function passed into another function as an argument to be executed later.
		Callback functions can be synchronous or asynchronous.

-------------------------------------------------------

Question:- how to combine arrays in javascript?
Ans: 1. By Spread operator: => console.log([...arr1, ...arr2, ...arr3])
	 2. By concate function: =>
	 
	 	const arr1 = ["Cecilie", "Lone"];
		const arr2 = ["Emil", "Tobias", "Linus"];
		const arr3 = ["Robin"];

		const children = arr1.concat(arr2, arr3);
		console.log(children)

	3. By push method: =>

		const arr1 = ["Cecilie", "Lone"];
		const arr2 = ["Emil", "Tobias", "Linus"];
		const arr3 = ["Robin"];
		arr1.push(...arr2);
		console.log(arr1)

-------------------------------------------------------

Questions:- Explain Event bubbling and Event Capturing in JavaScript?
Ans:- 

-------------------------------------------------------
Shallow copy Vs Deep copy

Shallow copy :  Coping on top level elements
Deep Copy :  Copying nested elements

var array = ['ram', 'shyam', 'krishna'];
var arrayNew = array;
	arrayNew[0] = '100';

console.log(arrayNew, array);


var car = {
	size = '100%',
	owner = 'ram',
	isACorNonAC = true
}

var otherCar = car;

otherCar.model = '0%';
car.isACorNonAC = false;

console.log(otherCar, car);


//Array Shallow Copy

1. Array.concate(array1);

var originalArray = ['100', '200', '300', {'a', 'hello'}]

2. Array.from(array1);

3. Array.slice(0);

4. Spread Operator [...];


//Array Deep Copy

Fast cloning with data loss - JSON.parse/stringify :-

If you do not use Dates, functions, undefined, Infinity, RegExps, Maps, Sets, Blobs, FileLists, ImageDatas, sparse Arrays, Typed Arrays or other complex types within your object, a very simple one liner to deep clone an object is:

JSON.parse(JSON.stringify(object))

1. JSON.parse(JSON.stringify(array1));


-------------------------------------------

//Object Shallow Copy

1. Object.assign({}, sourceObj);

2. Spread Operator = {...Obj};

//Object Deep Copy

Q1. JSON.parse(JSON.stringify(Obj));

Question :- Remove duplicate values from JS array

	1. uniq = [...new Set(array)];
	2. var names = ["Mike","Matt","Nancy","Adam","Jenny","Matt","Nancy","Carl"];

		let uniqueChars = names.filter((c, index) => {
			return names.indexOf(c) === index;
		});

		console.log(uniqueChars)

Q2. What is JavaScript?
Ans: Developed by Brendan Eich in 1995, JavaScript is one of the most popular languages for web development.
	It was initially created to develop dynamic web pages. Every JS program is called a script, which can be attached to any web page’s HTML.
	These scripts run automatically when the page loads.
	A language which was initially used to create dynamic web pages, can now be executed on the server and practically on any device consisting of the JavaScript Engine

	JavaScript was first known as LiveScript, but Netscape changed its name to JavaScript, possibly because of the excitement being generated by Java.
	JavaScript made its first appearance in Netscape 2.0 in 1995 with the name LiveScript

Q3. What are the data types supported by JavaScript?
Ans: The data types supported by JavaScript are:

	Primitive types

			Undefined: When a variable is declared but not assigned, it has the value of undefined and it’s type is also undefined.

					Example :
					var x; // value of x is undefined
					var y = undefined; // we can also set the value of a variable as undefined

			Null: It represents a non-existent or a invalid value.

					Example :
					var z = null;

			Boolean: It represents a logical entity and can have only two values : true or false. 
					Booleans are generally used for conditional testing.

					Example :
						var a = 2;
						var b =  3;
						var c =  2;
						(a == b) // returns false
						(a == c) //returns true

			String: It represents a series of characters and is written with quotes. 
					A string can be represented using a single or a double quote.

					Example :
						var str = "Vivek Singh Bisht"; //using double quotes
						var str2 = 'John Doe'; //using single quotes

			Symbol: It is a new data type introduced in the ES6 version of javascript. 
					It is used to store an anonymous and unique value.

					Example :
						var symbol1 = Symbol('symbol');

			Number: It represents a number and can be written with or without decimals.

					Example :
						var x = 3; //without decimal
						var y = 3.6; //with decimal
			
			BigInt - This data type is used to store numbers which are above the limitation of the Number data type. 
					It can store large integers and is represented by adding “n” to an integer literal.

					Example :
						var bigInteger =  234567890123456789012345678901234567890;

	Non-primitive types: 
						Primitive data types can store only a single value. 
						To store multiple and complex values, non-primitive data types are used.

			Object - Used to store collection of data.

				Example:
					// Collection of data in key-value pairs

					var obj1 = {
						x:  43,
						y:  "Hello world!",
						z: function(){
							return this.x;
						}
					}
						
					// Collection of data as an ordered list
						
					var array1 = [5, "Hello", true, 4.1]; 

Q4. What are the features of JavaScript?
Ans: It is a lightweight, interpreted programming language.

Q5. Is JavaScript a case-sensitive language?
Ans: Yes, JavaScript is a case sensitive language.

Q6. What are the advantages of JavaScript?

Q7. How can you create an object in JavaScript?
	JavaScript supports Object concept very well. You can create an object using the object literal as follows −

	var emp = {
		name: "Daniel",
		age: 23
	};

Q8. How can you create an Array in JavaScript?
	You can define arrays using the array literal as follows-

	var x = [];
	var y = [1, 2, 3, 4, 5];

Q9. What is a name function in JavaScript & how to define it?
	A named function declares a name as soon as it is defined. It can be defined using function keyword as :

	function named(){
	// write code here
	}

Q11. What is argument objects in JavaScript & how to get the type of arguments passed to a function?
Ans: JavaScript variable arguments represents the arguments that are passed to a function. Using typeof operator, we can get the type of arguments passed to a function. For example −

	function func(x){
		console.log(typeof x, arguments.length);
	}

	func(); //==> "undefined", 0
	func(7); //==> "number", 1
	func("1", "2", "3"); //==> "string", 3

Q15. What is Closure? Give an example.
Ans:- In JavaScript, closures are defined as inner functions that have access to variables and parameters of outer function even after the outer function has returned.

	In other words, a closure gives you access to an outer function’s scope from an inner function.

	In JavaScript, closures are the primary mechanism used to enable data privacy. When you use closures for data privacy, the enclosed variables are only in scope within the containing (outer) function. You can’t get at the data from an outside scope except through the object’s privileged methods.

	One common usage of closures is to provide information-hiding, which is helpful in bringing some kind of encapsulation to the language.

	function foo(msg) {

		function bar() {
			// I can access foo's scope
			// (i.e. bar can access everything that foo can access)
			alert(msg);
		}

		return bar;

	}

	// Define the closure
	function multFn() {
		var mult = 9;
		return function(val) {
			mult = mult * val;
			return mult;
		}
	}

	// Use the closure
	var mult = multFn();
	console.log(mult(18));


foo('hello')(); // alerts "hello"

Q18. How does TypeOf Operator work?
Ans:- The typeof operator is used to get the data type of its operand. 
	The operand can be either a literal or a data structure such as a variable, a function, or an object. 
	It is a unary operator that is placed before its single operand, which can be of any type. 
	Its value is a string indicating the data type of the operand

Q19. How to create a cookie using JavaScript?
Ans:- Cookies are data, stored in small text files, on your computer.
	The simplest way to create a cookie is to assign a string value to the document.cookie object.
	You can also add an expiry date (in UTC time). By default, the cookie is deleted when the browser is closed:
	document.cookie = "username=John Doe; expires=Thu, 18 Dec 2013 12:00:00 UTC";

Q21. How to delete a cookie using JavaScript?

Q25. What are the ways to define a variable in JavaScript?
Ans:- The three possible ways of defining a variable in JavaScript are: var, let and const;
	The final salient difference between let / const and var is that if you access var before it's declared, it is undefined. 
	But if you do the same for let and const, they throw a ReferenceError.

Q12: What is the Temporal Dead Zone (TDZ) in JavaScript?

	They throw the error all because of the Temporal Dead Zone.



Q27. What is the difference between Local storage & Session storage?
Ans:- Local Storage – The data is not sent back to the server for every HTTP request (HTML, images, JavaScript, CSS, etc) – reducing the amount of traffic between client and server. It will stay until it is manually cleared through settings or program.
		localStorage.setItem(key, value)	=> It is used to store the value in a particular location with the name of the key
		localStorage.getItem(key, value)   	=> This method takes one parameter that is key which is used to get the value stored with a particular key name.
		localStorage.removeItem(key)		=> This is method is used to remove the value stored in the memory in reference to key
		localStorage.clear() 				=> This method is used to clear all the values stored in localstorage.

	  Session Storage – It is similar to local storage; the only difference is while data stored in local storage has no expiration time, data stored in session storage gets cleared when the page session ends. Session Storage will leave when the browser is closed.
		sessionStorage.setItem(key, value)
		sessionStorage.getItem(key)
		sessionStorage.removeItem(key)
		sessionStorage.clear()


https://www.edureka.co/blog/interview-questions/javascript-interview-questions/


Q2. Explain Hoisting in javascript.
Ans:- Hoisting is a default behaviour of javascript where all the variable and function declarations are moved on top.


		This means that irrespective of where the variables and functions are declared, they are moved on top of the scope. The scope can be both local and global.

		Example 1:

			hoistedVariable = 3;
			console.log(hoistedVariable); // outputs 3 even when the variable is declared after it is initialized	
			var hoistedVariable;

		Example 2:

			hoistedFunction();  // Outputs " Hello world! " even when the function is declared after calling

				function hoistedFunction(){ 
				console.log(" Hello world! ");
			}

		Example 3:

			// Hoisting takes place in the local scope as well
			function doSomething(){
				x = 33;
				console.log(x);
				var x;
			}

			doSomething(); // Outputs 33 since the local variable “x” is hoisted inside the local scope


Q6. What is NaN property in JavaScript?
Ans:- NaN property represents “Not-a-Number” value. It indicates a value which is not a legal number.

		typeof of a NaN will return a Number .

		To check if a value is NaN, we use the isNaN() function,

		**Note- isNaN() function converts the given value to a Number type, and then equates to NaN.
		isNaN("Hello")  // Returns true
		isNaN(345)   // Returns false
		isNaN('1')  // Returns false, since '1' is converted to Number type which results in 0 ( a number) 
		isNaN(true) // Returns false, since true converted to Number type results in 1 ( a number)
		isNaN(false) // Returns false
		isNaN(undefined) // Returns true
	

Q8. What is an Immediately Invoked Function in JavaScript?
Ans:- An Immediately Invoked Function ( known as IIFE and pronounced as IIFY) is a function that runs as soon as it is defined.

		Syntax of IIFE :

		(function(){ 
			// Do something;
		})();

		To understand IIFE, we need to understand the two sets of parentheses which are added while creating an IIFE :

		First set of parenthesis:

		(function (){
			//Do something;
		})

		While executing javascript code, whenever the compiler sees the word “function”, it assumes that we are declaring a function in the code.
		Therefore, if we do not use the first set of parentheses, the compiler throws an error because it thinks we are declaring a function,
		and by the syntax of declaring a function, a function should always have a name.

Q9. Explain Higher Order Functions in javascript.
Ans:- Functions that operate on other functions, either by taking them as arguments or by returning them, are called higher-order functions.

		Higher order functions are a result of functions being first-class citizens in javascript.

		Examples of higher order functions:

		function higherOrder(fn) {
		fn();
		}
     
		higherOrder(function() { console.log("Hello world") }); 

		function higherOrder2() {
		return function() {
			return "Do something";
		}
		}
				
		var x = higherOrder2();
		x()   // Returns "Do something"

Q10. Explain “this” keyword.
Ans:- The “this” keyword refers to the object that the function is a property of.

		The value of “this” keyword will always depend on the object that is invoking the function.

		Confused? Let’s understand the above statements by examples:
		function doSomething() {
			console.log(this);
		}
        
		doSomething();

		What do you think the output of the above code will be?

		Example 2:

		var obj = {
			name:  "vivek",
			getName: function(){
				console.log(this.name);
			}
		}
				
		obj.getName();

		In the above code, at the time of invocation, the getName function is a property of the object obj , therefore, the this keyword will refer to the object obj , and hence the output will be “vivek”.

		Example 3:

		var obj = {
			name:  "vivek",
			getName: function(){
				console.log(this.name);
			}
		}
				
		var getName = obj.getName;
				
		var obj2 = {name:"akshay", getName };
		obj2.getName();

		Can you guess the output here?

		The output will be “akshay”.

		Although the getName function is declared inside the object obj , at the time of invocation, getName() is a property of obj2 , therefore the “this” keyword will refer to obj2 .


		The silly way to understanding the this keyword is, whenever the function is invoked, check the object before the dot . The value of this . keyword will always be the object before the dot .

		If there is no object before the dot like in example1, the value of this keyword will be the global object.

		Example 4:

		var obj1 = {
			address : "Mumbai,India",
			getAddress: function(){
				console.log(this.address); 
			}
		}
			
		var getAddress = obj1.getAddress;
		var obj2 = {name:"akshay"};
		obj2.getAddress();    

		Can you guess the output?

		The output will be an error.

		Although in the code above, the this keyword refers to the object obj2 , obj2 does not have the property “address”‘, hence the getAddress function throws an error.


Q5: What is the Temporal Dead Zone (TDZ) in JavaScript?
Ans:- 

Q6: What is Javascript Engine? How is it works?
Ans:- A JavaScript engine is a software component that executes JavaScript code. The first JavaScript engines were mere interpreters, but all relevant modern engines use       just-in-time compilation for improved performance.[1]

	JavaScript engines are typically developed by web browser vendors, and every major browser has one.

	The first modern JavaScript engine was V8, created by Google for its Chrome browser. V8 debuted as part of Chrome in 2008, and its performance was much better than any prior engine.[2][3] The key innovation was just-in-time compilation, which can significantly improve execution times.

	Apple's Safari browser is used JavaScriptCore is the built-in JavaScript engine for WebKit.
	JavaScriptCore is often referred with different names, such as ​SquirrelFish and ​SquirrelFish Extreme. Within the context of Safari, Nitro and Nitro Extreme are also commonly used. However, the name of the project and the library is always JavaScriptCore.

	Chakra is the engine of the Internet Explorer browser. It was also forked by Microsoft for the original Edge browser, but Edge was later rebuilt as a Chromium-based browser and thus now uses V8.

Q7:	What is DOM creation? Explain Shadow DOM, Web components in JavaScript?
Ans:- DOM stands for Document Object Model. DOM contains a bunch of nodes where each node represents an HTML element. The DOM views an HTML document as a tree of nodes. A node represents an HTML element. We can access these elements in the document and make changes to them using JavaScript.

	The Document Object Model (DOM) is a programming interface for web documents. It represents the page so that programs can change the document structure, style, and content. The DOM represents the document as nodes and objects; that way, programming languages can interact with the page.

	There are a few different methods for selecting an element in the HTML document.

	Shadow DOM :
	Shadow DOM serves for encapsulation. It allows a component to have its very own “shadow” DOM tree, that can’t be accidentally accessed from the main document, may have local style rules, and more.
	
Q8: How does the this keyword work? Provide some code examples
Q9: What is the difference between slice and splice?
Ans: 

	Some of the major difference in a tabular form

	Slice											Splice
	Doesn't modify the original array(immutable)	Modifies the original array(mutable)
	Returns the subset of original array			Returns the deleted elements as array
	Used to pick the elements from array			Used to insert or delete elements to/from array


Q38: What do you understand by event bubbling?
Ans: Event flow specifies the order in which events are received on the page from the element where the event occurs and propagated through the DOM tree. There are two main event models: event bubbling and event capturing.

	In the event bubbling model (bottom to top), an event starts at the most particular element and then flows upward toward the least specific element i.e., the document or even the window. For example, you have a div element and a button inside the div element when the button triggers a click event, the click event occurs in the following order:

	button

	div with the id container

	body

	html

	Document

	The click event first occurs on the button, which is the element that was clicked. Then the click event goes up the DOM tree, firing on each node along its way until it reaches the document object. Few web browsers these days will bubble the event up to the window object.

	https://javascript.info/bubbling-and-capturing

	Event bubbling and capturing are two ways of event propagation in the HTML DOM API, when an event occurs in an element inside another element, and both elements have registered a handle for that event. The event propagation mode determines in which order the elements receive the event.

	With bubbling, the event is first captured and handled by the innermost element and then propagated to outer elements.

	With capturing, the event is first captured by the outermost element and propagated to the inner elements.

	Capturing is also called "trickling", which helps remember the propagation order:

	e.stopPropagation();  //syntax to stop event bubbling

Q15: Difference between regular functions and arrow functions?
Ans:- 
	1. Syntax:-

		Syntax of regular functions:-

		let x = function function_name(parameters){
		// body of the function
		};
		Example of regular functions:-

		let square = function(x){
		return (x*x);
		};
		console.log(square(9));

		The syntax of arrow functions:-

		let x = (parameters) => {
			// body of the function
		};
		Example of arrow functions:-

		var square = (x) => {
			return (x*x);
		};
		console.log(square(9));

	2. Use of this keyword:-

		Unlike regular functions, arrow functions do not have their own this.
		For example:-

		let user = {
			name: "GFG",
			gfg1:() => {
				console.log("hello " + this.name); // no 'this' binding here
			},
			gfg2(){       
				console.log("Welcome to " + this.name); // 'this' binding works here
			}  
		};
		user.gfg1();
		user.gfg2(); 

	3. Availability of arguments objects:-

		rguments objects are not available in arrow functions, but are available in regular functions.

		Example using regular ():-

		let user = {      
			show(){
				console.log(arguments);
			}
		};
		user.show(1, 2, 3);

		Example using arrow ():-

		let user = {     
				show_ar : () => {
				console.log(...arguments);
			}
		};
		user.show_ar(1, 2, 3);

		This will show Uncaught ReferenceError: arguments is not defined.
	
	4. Using new keyword:-

		Regular functions created using function declarations or expressions are ‘constructible’ and ‘callable’. Since regular functions are constructible, they can be called using the ‘new’ keyword. However, the arrow functions are only ‘callable’ and not constructible. Thus, we will get a run-time error on trying to construct a non-constructible arrow functions using the new keyword.

		Example using regular function:-

		let x = function(){
			console.log(arguments);
		};
		new x =(1,2,3);

		Example using arrow function:-

		let x = ()=> {
			console.log(arguments);
		};
		new x(1,2,3);

		This will show Uncaught TypeError: x is not a constructor.

Q17: What is the difference between using Object.defineProperty and Object.freeze?
Ans:- 

	Object.freeze()

	The Object.freeze() method freezes an object. A frozen object can no longer be changed; freezing an object prevents new properties from being added to it, existing properties from being removed, prevents changing the enumerability, configurability, or writability of existing properties, and prevents the values of existing properties from being changed. In addition, freezing an object also prevents its prototype from being changed.

	Object.freeze() makes an object immune to everything even little changes cannot be made

	we can not add/remove new property or can not remove existing.

	Object.defineProperty()

		The static method Object.defineProperty() defines a new property directly on an object, or modifies an existing property on an object, and returns the object.

		we can add/remove new property but can not change/delete in existing.

	Object.seal()
		The Object.seal() method seals an object, preventing new properties from being added to it and marking all existing properties as non-configurable. Values of present properties can still be changed as long as they are writable.

		It prevents adding and/or removing properties from the sealed object; using delete will return false.
		we can not add/remove new property but can change existing property.

